# summary(gamm_model$lme)
# # Check residuals for the GAMM model
# plot(gamm_model$lme, resid(., type = "pearson"), xlab = "Fitted values", ylab = "Pearson residuals")
# abline(h = 0, lty = 2, col = "red")
# qqnorm(resid(gamm_model$lme, type = "pearson"))
# qqline(resid(gamm_model$lme, type = "pearson"))
# # Step 3: Generalized linear mixed model (GLMM)
# # Fit a GLMM with Gamma distribution and log link function
# glmm_gamma <- glmmTMB(rel_conc_imputed ~ Treatment + (1 | Colony),
#                       data = GENE_data,
#                       family = Gamma(link = "log"))
# qqnorm(resid(glmm_gamma, type = "pearson"))
# qqline(resid(glmm_gamma, type = "pearson"))
#
# mod1 <- lmer(log10(rel_conc_imputed + GENE_cost) ~ Treatment + (1 | Colony), data = GENE_data) # ,weights = weights
# print(GENE)
# output_lmer(mod1)
# # hist(residuals(mod1))
# # qqnorm(residuals(mod1))
# # qqline(residuals(mod1))
# out.put <- model.sel(mod1)
# # models sorted from best (top) to worst (bottom). higher weight is better as it shows that the model is more likely to be the best explanation (hypothesis) for variation in rel_conc_imputed
# sel.table <- nice_print_model_sel(out.put)
# print(GENE)
# print(sel.table)
# # compute posthocs
# sel_mod <- get(sel.table[which.max(sel.table$weight), "Model"])
# ID_model <- paste(GROUP,GENE,sep="-") # to assign name to posthoc's list element
# posthoc_list <- compute_posthocs(sel_mod)
# #given the tiny group size, and the non-relevance of the random factor Colony, use a non-parametric test
# #Wilcoxon rank-sum test (also known as the Mann-Whitney U test)
# mod_T <- rstatix::wilcox_test(rel_conc_imputed ~ Treatment, data = GENE_data, alternative = "two.sided")
# #save test information
# mod_T_list <- c(mod_T_list, list(mod_T))
# ID_model <- paste(GROUP,GENE,sep="-")
# names(mod_T_list)[length(mod_T_list)] <- paste(ID_model, sep = "-")
# mod_T_list[length(mod_T_list)]
#
}
#### QUEENS (no status grouping, no random)
else if (unique(GENE_data$GROUP)=="QUEEN") {
if (QUEEN_data_OK) {
#given the tiny group size, and the non-relevance of the random factor Colony, use a non-parametric test
#Wilcoxon rank-sum test (also known as the Mann-Whitney U test)
mod_Q <- rstatix::wilcox_test(rel_conc_imputed ~ Treatment, data = GENE_data, alternative = "two.sided")
if (REPORT) {
Report_stats <- c(Report_stats, list(paste(
GROUP,
GENE,
wilcox.test(GENE_data$rel_conc_imputed ~ GENE_data$Treatment, alternative = "two.sided", exact=F) %>% report()
, sep= " - ")))
}
#save test information
mod_Q_list <- c(mod_Q_list, list(mod_Q))
ID_model <- paste(GROUP,GENE,sep="-")
names(mod_Q_list)[length(mod_Q_list)] <- paste(ID_model, sep = "-")
mod_Q_list[length(mod_Q_list)]
#mod1 <- lmer(rel_conc_imputed + GENE_cost ~ Treatment + (1 | Colony), data = GENE_data)
# mod1 <- glm(log10(rel_conc_imputed + GENE_cost) ~ Treatment, data = GENE_data) # ,weights = weights
# print(GENE)
# output_lmer(mod1)
# # run anova and store the significant variables in the object SIG
# SIG <- as.data.frame(Anova(mod1)[Anova(mod1)$"Pr(>Chisq)" < 0.05])
# if (ncol(SIG)==0) {
#   SIG <- data.frame(LR.Chisq=NA,Df=NA,Pr="n.s.")
# }else{
# SIG$Pr <- round(SIG$"Pr(>Chisq)",3)
# SIG$"Pr(>Chisq)" <- NULL
#
# SIG$LR.Chisq <- SIG$"LR Chisq"
# SIG$"LR Chisq" <- NULL
#
# }
# #save test information
#mod_Q_list <- c(mod_Q_list, list(SIG))
#ID_model <- paste(GROUP,GENE,sep="-")
#names(mod_Q_list)[length(mod_Q_list)] <- paste(ID_model, sep = "-")
}
}
#### UNTREATED INDIVIDUALS
else{
# First,fir candidate linear models to explain variation in density
mod1 <- lmer(log10(rel_conc_imputed) ~ Treatment + Ant_status + (1 | Colony), data = GENE_data)
if (REPORT) {
if (REPORT) {
Report_stats <- c(Report_stats, list(paste(
GROUP,
GENE,
mod1 %>% report()
, sep= " - ")))
}
}
#mod2 <- lmer(log10(rel_conc_imputed + GENE_cost) ~ Treatment + Ant_status + (1 | Colony), data = GENE_data) # weights = weights,
# We can now use the mod.sel to conduct model selection. The default model selection criteria is Akaike’s information criteria (AIC) with small sample bias adjustment, AICc
# delta AICc, and the model weights
out.put <- model.sel(mod1) #,mod2
# models sorted from best (top) to worst (bottom). higher weight is better as it shows that the model is more likely to be the best explanation (hypothesis) for variation in rel_conc_imputed
sel.table <- nice_print_model_sel(out.put)
print(paste(GROUP,GENE,sep=" : "))
print(sel.table)
# compute posthocs
sel_mod <- get(sel.table[which.max(sel.table$weight), "Model"])
print(paste0("##################",GENE,"####################"))
output_lmer(sel_mod)
ID_model <- paste(GROUP,GENE,sep="-") # to assign name to posthoc's list element
#posthoc_list <- compute_posthocs(sel_mod)
# #extract significance
# mod_Q_list <- c(mod_Q_list, list(mod_Q))
# ID_model <- paste(GROUP,GENE,sep="-")
# names(mod_Q_list)[length(mod_Q_list)] <- paste(ID_model, sep = "-")
# mod_Q_list[length(mod_Q_list)]
#
#
# gamlss_sig <- as.data.frame(summary(gamlss_model, coef.only = TRUE))
# gamlss_sig$p <- round(gamlss_sig$"Pr(>|t|)",3)
# gamlss_sig$"Pr(>|t|)" <- NULL
# mod_T_list <- c(mod_T_list, list(gamlss_sig[!grepl("Intercept", rownames(gamlss_sig)), ]))
# ID_model <- paste(GROUP,GENE,sep="-")
# names(mod_T_list)[length(mod_T_list)] <- paste(ID_model, sep = "-")
# mod_T_list[length(mod_T_list)]
## Reporting  model estimates for fixed effects in Untreated nurses tests
estimates <- summary(mod1)$coefficients
fixed_effects <- estimates[grep("Treatment|Ant_status", rownames(estimates)), 1]
#intercept <- estimates[1, 1]
# Add fixed effects to intercept
#final_estimates <- intercept + fixed_effects
final_estimates <- fixed_effects
Estim.Status <- final_estimates[grep("Ant_status",names(final_estimates))]
Estim.Treatment <-final_estimates[grep("Treatment",names(final_estimates))]
## Reporting Pvalues in Untreated nurses tests
P.Status <- Anova(mod1)[grep("Ant_status", row.names(Anova(mod1))),"Pr(>Chisq)"]
P.Treatment <- Anova(mod1)[grep("Treatment", row.names(Anova(mod1))),"Pr(>Chisq)"]
# Add results to the data frame
PipelineTesting <- rbind(PipelineTesting, data.frame(gene = GENE,
P.Status = P.Status,
P.Treatment = P.Treatment,
Estim.Status = Estim.Status,
Estim.Treatment = Estim.Treatment,
T.E. = Technical_error,
LOD = Limit_of_Detection,
ALWAYS_DISCARD=ALWAYS_DISCARD,
imputation  = IMPUTATION,
Invalids  = INVALIDS))
rownames(PipelineTesting) <- NULL
# # Create the pairwise comparisons of treatments and ant status:
# contrasts <- emmeans(sel_mod, pairwise ~ Treatment * Ant_status, adjust = "tukey")
# lt <- as.data.frame(cld(contrasts, Letters = letters, decreasing = TRUE))
# # Give the rows meaningful names:
# mod_UN_list <- c(mod_UN_list,list(lt))
# names(mod_UN_list)[length(mod_UN_list)] <- paste(ID_model,deparse(substitute(sel_mod)),sep = "-")
#
#   #emmeans is used to calculate and display the predicted marginal means (i.e., average predicted values)
#   # for different combinations of the categorical predictor variables Treatment and Ant_status, in the GLM model mod1.
#   posthocDF = data.frame(emmeans(mod1, ~ Treatment * Ant_status, type="response"))
#
#   if (PLOT) {
#   print(
#     ggplot(posthocDF, aes(x=Ant_status, y=response, fill=Treatment)) +
#       geom_bar(stat="identity",position ="dodge", width=0.5) +
#       geom_errorbar(aes(ymin=lower.CL, ymax=upper.CL), width=0, size= .5,
#                     position=position_dodge(.5))+
#       colFill_Treatment +
#       colScale_Treatment +
#       STYLE + #theme_few() +
#       ggtitle(paste(GENE,"\npredicted marginal means", collapse = ", "),) +
#       theme(plot.title = element_text(size = 9)) +
#       ylab("rel. concentration")
#   )
#
#
#   #if the interaction is not significant, the lines in the plot should be approximately parallel, indicating that there is no significant difference in the spread of rel_conc_imputed between Task groups across treatments
#   ggplot(posthocDF, aes(x = Ant_status, y = response, group = Treatment, color = Treatment)) +
#     geom_line(size = 1) +
#     geom_ribbon(aes(ymin = lower.CL, ymax = upper.CL, fill = Treatment), alpha = 0.2) +
#     colFill_Treatment +
#     colScale_Treatment +
#     STYLE + #theme_few() +
#     ggtitle(paste(GENE, "\npredicted marginal means", collapse = ", "),) +
#     theme(plot.title = element_text(size = 9)) +
#     ylab("rel. concentration") +
#     scale_x_discrete(expand = c(0, 0))
#   }
# Calculate coefficient of variation
cv_data <- GENE_data_VAR %>%
group_by(Colony, Treatment) %>%
summarise(
mean_rel_conc = mean(rel_conc_imputed, na.rm = TRUE),
sd_rel_conc = sd(rel_conc_imputed, na.rm = TRUE)
) %>%
mutate(cv = (sd_rel_conc / mean_rel_conc)) %>%
ungroup()
mod_CV <-  rstatix::wilcox_test(cv ~ Treatment, data = cv_data, alternative = "two.sided")
if (mod_CV$p < 0.05) {
cv_control_small <- mean(cv_data$cv[cv_data$Treatment == "control.small"])
cv_control_big <- mean(cv_data$cv[cv_data$Treatment == "control.big"])
print(paste0("The variance in expression of ", GENE, " for untreated workers is significant (p-value ", round(mod_CV$p, 3),
"). CV for control.small is ", round(cv_control_small, 3),
", for control.big is ", round(cv_control_big, 3), "."))
}
# Store results
results_untreat_var[[GENE]] <- list( W = mod_CV$statistic, P = mod_CV$p, N = nrow(cv_data))
}
}
}
CLEAN_DATA$Treatment <- as.factor(CLEAN_DATA$Treatment)
CLEAN_DATA <- as.data.frame(CLEAN_DATA)
QUEEN_data_OK <- TRUE # queen data may be worth to reprocess as a few get discarded
warning(paste0("QUEEN_data_OK: ", QUEEN_data_OK))
#create list of significance outputs for Q data
mod_Q_list <- list()
#create list of significance outputs for treated data
mod_T_list <- list()
##temporary list for untreated
mod_UN_list <- list()
## variance test results
results_untreat_var <- list()
for (GROUP in unique(CLEAN_DATA$GROUP)) {
print(GROUP)
table(CLEAN_DATA[which(CLEAN_DATA$GROUP==GROUP),"Treatment"],CLEAN_DATA[which(CLEAN_DATA$GROUP==GROUP),"gene"])
for (GENE in unique(CLEAN_DATA$gene)) {
# select subset for 1 gene
#GENE_data <- DF[which(DF$gene == GENE), ]
GENE_data <- CLEAN_DATA[which(CLEAN_DATA$gene==GENE & CLEAN_DATA$GROUP==GROUP),
c("Colony","GROUP","Ant_status","gene","Treatment","rel_conc_imputed")]
# create constant to make values below zeros a small number
# GENE_cost <- min(GENE_data$rel_conc_imputed, na.rm = T) * 1.1
# hist(log10(GENE_data$rel_conc_imputed+GENE_cost))
#### TREATED INDIVIDUALS (no status grouping)
if (unique(GENE_data$GROUP)=="TREATED_W") {
# First, fit linear models to explain variation in density
# descdist(GENE_data$rel_conc_imputed)
# # Fit a GAMLSS model with lognormal distribution
# gamlss_model <- gamlss(rel_conc_imputed ~ Treatment + random(as.factor(Colony)),
#                        data = GENE_data,
#                        family =  ZAGA())
# # Plot residuals vs. fitted values
# # plot(fitted(gamlss_model), residuals(gamlss_model), xlab = "Fitted values", ylab = "Pearson residuals")
# # abline(h = 0, lty = 2, col = "red")
# # QQ plot of residuals
# Shap <- shapiro.test(residuals(gamlss_model))
# qqnorm(residuals(gamlss_model),main = paste(GROUP,GENE,"qqnorm","\nshap.test p=", round(Shap$p.value,4),sep=" "))
# qqline(residuals(gamlss_model))
# #https://www.gamlss.com/wp-content/uploads/2013/01/gamlss-manual.pdf
# wp(gamlss_model,xvar=~Treatment)
#
# #extract significance
# gamlss_sig <- as.data.frame(summary(gamlss_model, coef.only = TRUE))
# gamlss_sig$p <- round(gamlss_sig$"Pr(>|t|)",3)
# gamlss_sig$"Pr(>|t|)" <- NULL
# mod_T_list <- c(mod_T_list, list(gamlss_sig[!grepl("Intercept", rownames(gamlss_sig)), ]))
# ID_model <- paste(GROUP,GENE,sep="-")
# names(mod_T_list)[length(mod_T_list)] <- paste(ID_model, sep = "-")
# mod_T_list[length(mod_T_list)]
#
# # Fit the GAMM
# gamm_model <- gamm4((log10(rel_conc_imputed + GENE_cost)) ~ Treatment, random = ~ (1 | Colony), data = GENE_data)
# # Extract residuals
# gamm_residuals <- resid(gamm_model$gam, type = "pearson")
# # Plot residuals vs. fitted values
# plot(fitted(gamm_model$gam), gamm_residuals, xlab = "Fitted values", ylab = "Pearson residuals")
# abline(h = 0, lty = 2, col = "red")
# # QQ plot of residuals
# qqnorm(gamm_residuals)
# qqline(gamm_residuals)
# # Summary of the model
# summary(gamm_model$gam)
# # Summary of the random effects
# summary(gamm_model$lme)
# # Check residuals for the GAMM model
# plot(gamm_model$lme, resid(., type = "pearson"), xlab = "Fitted values", ylab = "Pearson residuals")
# abline(h = 0, lty = 2, col = "red")
# qqnorm(resid(gamm_model$lme, type = "pearson"))
# qqline(resid(gamm_model$lme, type = "pearson"))
# # Step 3: Generalized linear mixed model (GLMM)
# # Fit a GLMM with Gamma distribution and log link function
# glmm_gamma <- glmmTMB(rel_conc_imputed ~ Treatment + (1 | Colony),
#                       data = GENE_data,
#                       family = Gamma(link = "log"))
# qqnorm(resid(glmm_gamma, type = "pearson"))
# qqline(resid(glmm_gamma, type = "pearson"))
#
# mod1 <- lmer(log10(rel_conc_imputed + GENE_cost) ~ Treatment + (1 | Colony), data = GENE_data) # ,weights = weights
# print(GENE)
# output_lmer(mod1)
# # hist(residuals(mod1))
# # qqnorm(residuals(mod1))
# # qqline(residuals(mod1))
# out.put <- model.sel(mod1)
# # models sorted from best (top) to worst (bottom). higher weight is better as it shows that the model is more likely to be the best explanation (hypothesis) for variation in rel_conc_imputed
# sel.table <- nice_print_model_sel(out.put)
# print(GENE)
# print(sel.table)
# # compute posthocs
# sel_mod <- get(sel.table[which.max(sel.table$weight), "Model"])
# ID_model <- paste(GROUP,GENE,sep="-") # to assign name to posthoc's list element
# posthoc_list <- compute_posthocs(sel_mod)
# #given the tiny group size, and the non-relevance of the random factor Colony, use a non-parametric test
# #Wilcoxon rank-sum test (also known as the Mann-Whitney U test)
# mod_T <- rstatix::wilcox_test(rel_conc_imputed ~ Treatment, data = GENE_data, alternative = "two.sided")
# #save test information
# mod_T_list <- c(mod_T_list, list(mod_T))
# ID_model <- paste(GROUP,GENE,sep="-")
# names(mod_T_list)[length(mod_T_list)] <- paste(ID_model, sep = "-")
# mod_T_list[length(mod_T_list)]
#
}
#### QUEENS (no status grouping, no random)
else if (unique(GENE_data$GROUP)=="QUEEN") {
if (QUEEN_data_OK) {
#given the tiny group size, and the non-relevance of the random factor Colony, use a non-parametric test
#Wilcoxon rank-sum test (also known as the Mann-Whitney U test)
mod_Q <- rstatix::wilcox_test(rel_conc_imputed ~ Treatment, data = GENE_data, alternative = "two.sided")
if (REPORT) {
Report_stats <- c(Report_stats, list(paste(
GROUP,
GENE,
wilcox.test(GENE_data$rel_conc_imputed ~ GENE_data$Treatment, alternative = "two.sided", exact=F) %>% report()
, sep= " - ")))
}
#save test information
mod_Q_list <- c(mod_Q_list, list(mod_Q))
ID_model <- paste(GROUP,GENE,sep="-")
names(mod_Q_list)[length(mod_Q_list)] <- paste(ID_model, sep = "-")
mod_Q_list[length(mod_Q_list)]
#mod1 <- lmer(rel_conc_imputed + GENE_cost ~ Treatment + (1 | Colony), data = GENE_data)
# mod1 <- glm(log10(rel_conc_imputed + GENE_cost) ~ Treatment, data = GENE_data) # ,weights = weights
# print(GENE)
# output_lmer(mod1)
# # run anova and store the significant variables in the object SIG
# SIG <- as.data.frame(Anova(mod1)[Anova(mod1)$"Pr(>Chisq)" < 0.05])
# if (ncol(SIG)==0) {
#   SIG <- data.frame(LR.Chisq=NA,Df=NA,Pr="n.s.")
# }else{
# SIG$Pr <- round(SIG$"Pr(>Chisq)",3)
# SIG$"Pr(>Chisq)" <- NULL
#
# SIG$LR.Chisq <- SIG$"LR Chisq"
# SIG$"LR Chisq" <- NULL
#
# }
# #save test information
#mod_Q_list <- c(mod_Q_list, list(SIG))
#ID_model <- paste(GROUP,GENE,sep="-")
#names(mod_Q_list)[length(mod_Q_list)] <- paste(ID_model, sep = "-")
}
}
#### UNTREATED INDIVIDUALS
else{
# First,fir candidate linear models to explain variation in density
mod1 <- lmer(log10(rel_conc_imputed) ~ Treatment + Ant_status + (1 | Colony), data = GENE_data)
if (REPORT) {
if (REPORT) {
Report_stats <- c(Report_stats, list(paste(
GROUP,
GENE,
mod1 %>% report()
, sep= " - ")))
}
}
#mod2 <- lmer(log10(rel_conc_imputed + GENE_cost) ~ Treatment + Ant_status + (1 | Colony), data = GENE_data) # weights = weights,
# We can now use the mod.sel to conduct model selection. The default model selection criteria is Akaike’s information criteria (AIC) with small sample bias adjustment, AICc
# delta AICc, and the model weights
out.put <- model.sel(mod1) #,mod2
# models sorted from best (top) to worst (bottom). higher weight is better as it shows that the model is more likely to be the best explanation (hypothesis) for variation in rel_conc_imputed
sel.table <- nice_print_model_sel(out.put)
print(paste(GROUP,GENE,sep=" : "))
print(sel.table)
# compute posthocs
sel_mod <- get(sel.table[which.max(sel.table$weight), "Model"])
print(paste0("##################",GENE,"####################"))
output_lmer(sel_mod)
ID_model <- paste(GROUP,GENE,sep="-") # to assign name to posthoc's list element
#posthoc_list <- compute_posthocs(sel_mod)
# #extract significance
# mod_Q_list <- c(mod_Q_list, list(mod_Q))
# ID_model <- paste(GROUP,GENE,sep="-")
# names(mod_Q_list)[length(mod_Q_list)] <- paste(ID_model, sep = "-")
# mod_Q_list[length(mod_Q_list)]
#
#
# gamlss_sig <- as.data.frame(summary(gamlss_model, coef.only = TRUE))
# gamlss_sig$p <- round(gamlss_sig$"Pr(>|t|)",3)
# gamlss_sig$"Pr(>|t|)" <- NULL
# mod_T_list <- c(mod_T_list, list(gamlss_sig[!grepl("Intercept", rownames(gamlss_sig)), ]))
# ID_model <- paste(GROUP,GENE,sep="-")
# names(mod_T_list)[length(mod_T_list)] <- paste(ID_model, sep = "-")
# mod_T_list[length(mod_T_list)]
## Reporting  model estimates for fixed effects in Untreated nurses tests
estimates <- summary(mod1)$coefficients
fixed_effects <- estimates[grep("Treatment|Ant_status", rownames(estimates)), 1]
#intercept <- estimates[1, 1]
# Add fixed effects to intercept
#final_estimates <- intercept + fixed_effects
final_estimates <- fixed_effects
Estim.Status <- final_estimates[grep("Ant_status",names(final_estimates))]
Estim.Treatment <-final_estimates[grep("Treatment",names(final_estimates))]
## Reporting Pvalues in Untreated nurses tests
P.Status <- Anova(mod1)[grep("Ant_status", row.names(Anova(mod1))),"Pr(>Chisq)"]
P.Treatment <- Anova(mod1)[grep("Treatment", row.names(Anova(mod1))),"Pr(>Chisq)"]
# Add results to the data frame
PipelineTesting <- rbind(PipelineTesting, data.frame(gene = GENE,
P.Status = P.Status,
P.Treatment = P.Treatment,
Estim.Status = Estim.Status,
Estim.Treatment = Estim.Treatment,
T.E. = Technical_error,
LOD = Limit_of_Detection,
ALWAYS_DISCARD=ALWAYS_DISCARD,
imputation  = IMPUTATION,
Invalids  = INVALIDS))
rownames(PipelineTesting) <- NULL
# # Create the pairwise comparisons of treatments and ant status:
# contrasts <- emmeans(sel_mod, pairwise ~ Treatment * Ant_status, adjust = "tukey")
# lt <- as.data.frame(cld(contrasts, Letters = letters, decreasing = TRUE))
# # Give the rows meaningful names:
# mod_UN_list <- c(mod_UN_list,list(lt))
# names(mod_UN_list)[length(mod_UN_list)] <- paste(ID_model,deparse(substitute(sel_mod)),sep = "-")
#
#   #emmeans is used to calculate and display the predicted marginal means (i.e., average predicted values)
#   # for different combinations of the categorical predictor variables Treatment and Ant_status, in the GLM model mod1.
#   posthocDF = data.frame(emmeans(mod1, ~ Treatment * Ant_status, type="response"))
#
#   if (PLOT) {
#   print(
#     ggplot(posthocDF, aes(x=Ant_status, y=response, fill=Treatment)) +
#       geom_bar(stat="identity",position ="dodge", width=0.5) +
#       geom_errorbar(aes(ymin=lower.CL, ymax=upper.CL), width=0, size= .5,
#                     position=position_dodge(.5))+
#       colFill_Treatment +
#       colScale_Treatment +
#       STYLE + #theme_few() +
#       ggtitle(paste(GENE,"\npredicted marginal means", collapse = ", "),) +
#       theme(plot.title = element_text(size = 9)) +
#       ylab("rel. concentration")
#   )
#
#
#   #if the interaction is not significant, the lines in the plot should be approximately parallel, indicating that there is no significant difference in the spread of rel_conc_imputed between Task groups across treatments
#   ggplot(posthocDF, aes(x = Ant_status, y = response, group = Treatment, color = Treatment)) +
#     geom_line(size = 1) +
#     geom_ribbon(aes(ymin = lower.CL, ymax = upper.CL, fill = Treatment), alpha = 0.2) +
#     colFill_Treatment +
#     colScale_Treatment +
#     STYLE + #theme_few() +
#     ggtitle(paste(GENE, "\npredicted marginal means", collapse = ", "),) +
#     theme(plot.title = element_text(size = 9)) +
#     ylab("rel. concentration") +
#     scale_x_discrete(expand = c(0, 0))
#   }
# Calculate coefficient of variation
cv_data <- GENE_data_VAR %>%
group_by(Colony, Treatment) %>%
summarise(
mean_rel_conc = mean(rel_conc_imputed, na.rm = TRUE),
sd_rel_conc = sd(rel_conc_imputed, na.rm = TRUE)
) %>%
mutate(cv = (sd_rel_conc / mean_rel_conc)) %>%
ungroup()
mod_CV <-  rstatix::wilcox_test(cv ~ Treatment, data = cv_data, alternative = "two.sided")
if (mod_CV$p < 0.05) {
cv_control_small <- mean(cv_data$cv[cv_data$Treatment == "control.small"])
cv_control_big <- mean(cv_data$cv[cv_data$Treatment == "control.big"])
print(paste0("The variance in expression of ", GENE, " for untreated workers is significant (p-value ", round(mod_CV$p, 3),
"). CV for control.small is ", round(cv_control_small, 3),
", for control.big is ", round(cv_control_big, 3), "."))
}
# Store results
results_untreat_var[[GENE]] <- list( W = mod_CV$statistic, P = mod_CV$p, N = nrow(cv_data))
}
}
}
# Print results in the desired format
output <- "variance in gene expression for untreated workers (Wilcoxon rank sum test, "
output <- paste0(output, paste(sapply(names(results_untreat_var), function(gene) {
paste0(tolower(gene), ": W = ", results_untreat_var[[gene]]$W, ", P = ", round(results_untreat_var[[gene]]$P, 3), "; N = ", results_untreat_var[[gene]]$N)
}), collapse = "; "), ").")
print(output)
output
results_untreat_var
results_untreat_var
results_untreat_var
results_untreat_var[[GENE]]
results_untreat_var
results_untreat_var <- list()
#Calculate the variance in expression by taskgroup
for (GENE in unique(CLEAN_DATA$gene)) {
print(paste0("##################",GENE,"####################"))
GENE_data_VAR <- CLEAN_DATA[which(CLEAN_DATA$gene==GENE & CLEAN_DATA$GROUP=="UNTREATED_W"),
c("Colony","GROUP","Ant_status","gene","Treatment","rel_conc_imputed")]
# Calculate coefficient of variation
cv_data <- GENE_data_VAR %>%
group_by(Colony, Treatment) %>%
summarise(
mean_rel_conc = mean(rel_conc_imputed, na.rm = TRUE),
sd_rel_conc = sd(rel_conc_imputed, na.rm = TRUE)
) %>%
mutate(cv = (sd_rel_conc / mean_rel_conc)) %>%
ungroup()
mod_CV <-  rstatix::wilcox_test(cv ~ Treatment, data = cv_data, alternative = "two.sided")
if (mod_CV$p < 0.05) {
cv_control_small <- mean(cv_data$cv[cv_data$Treatment == "control.small"])
cv_control_big <- mean(cv_data$cv[cv_data$Treatment == "control.big"])
print(paste0("The variance in expression of ", GENE, " is significant (p-value ", round(mod_CV$p, 3),
"). CV for control.small is ", round(cv_control_small, 3),
", for control.big is ", round(cv_control_big, 3), "."))
}
# Store results
results_untreat_var[[GENE]] <- list( W = mod_CV$statistic, P = mod_CV$p, N = nrow(cv_data))
}
output
results_untreat_var
names(results_untreat_var)
